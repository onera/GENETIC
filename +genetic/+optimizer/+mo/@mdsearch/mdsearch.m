% Copyright 2018 ONERA
%
% This file is part of the GENETIC project.
%
% GENETIC is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License version 3 as
% published by the Free Software Foundation.
%
% GENETIC is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU Lesser General Public License for more details.
%
% You should have received a copy of the GNU Lesser General Public License
% along with GENETIC.  If not, see <https://www.gnu.org/licenses/lgpl-3.0>.
%
classdef mdsearch < genetic.optimizer.mono & genetic.optimizer.simpleScheme
   % MDSEARCH - Multi-Directional Search
   %
   %  MDSEARCH is a direct search algorithm that is ideally suited for
   %  parallel computation. This algorithm belongs to the class of direct
   %  search methods, which neither compute nor approximate any derivatives
   %  of the objective function. Based on the simplex methods of Spendley,
   %  Hext, and Himsworth, and of Nelder and Mead, the basic idea of the
   %  algorithm is to perform concurrent searches in multiple directions.
   %  These searches are free of any interdependencies, so the information
   %  required can be computed in parallel.
   %
   %  By requiring only that the objective function be continuously
   %  differentiable over a bounded level set, it can be proved that a
   %  subsequence of the points generated by the MDSEARCH algorithm
   %  converges to a stationary point of the objective function.
   %
   % References
   %  [1] V.J. Torczon, Multi-directional search: A direct search algorithm for
   %      parallel machines, Ph.D. Thesis, Rice University, 1989.
   %  [2] V.J. Torczon, On the convergence of the multidirectional search
   %      algorithm, SIAM J. Optimization, 1 (1991), pp. 123-145.
   %  [3] N.J. Higham, Optimization by direct search in matrix computations,
   %      SIAM J. Matrix Anal. Appl, 14(2): 317-333, 1993.
   %  [4] N.J. Higham, Accuracy and Stability of Numerical Algorithms,
   %      Second edition, Society for Industrial and Applied Mathematics,
   %      Philadelphia, PA, 2002; sec. 20.5.
   %
   properties
      tolSimplexSize       = 1e-8;

      initialSimplex       = 'right';
      initialSimplexSize   = [];
      %
      expandCoef           = 2;
      contractCoef         = 1/2;
   end
   properties(SetAccess=protected)
      %
      simplexX
      simplexY
      %
      reflectedX
      reflectedY
      %
      phase           = 'reflect';
   end
   methods
      %% constructor
      function self = mdsearch(varargin)
         self@genetic.optimizer.mono(varargin{:})
         self@genetic.optimizer.simpleScheme()
         %
         self.popSize      = 1;
         self.methodName   = 'mdsearch';
         self.longName     = 'Multi-Directional Search';
         %
         self.toDisplay{2}.name = 'iter';
         % Adding stopping criterion concerning the size of the simplex
         simplexTooSmall = struct('name', 'simplexTooSmall', 'cleanStop', true, 'condByConstraints', false);
         self.addStopTest(simplexTooSmall);
         % Adding printing function
         simpSize        = struct('name','simplexSize','call','printSimplexSize','align','c','dim',16);
         self.addDisplayElement(simpSize);
      end
      %%
      function sortSimplex(self)
         [self.simplexY, idx] = sort(self.simplexY,'ascend');
         self.simplexX        = self.simplexX(:,idx);
      end
      %% simplexSize
      function s = simplexSize(self)
         v1 = self.simplexX(:,1);         
         s  = norm(self.simplexX(:,2:self.xDim + 1) - repmat(v1,1,self.xDim),1) / max(1, norm(v1,1));
      end
      %% evolve
      function group = evolve(obj, group)
         xDim  = group.xDim;
         pivot = repmat(obj.simplexX(:,1),1,xDim);
         switch obj.phase
            case 'reflect'
               newVal         = pivot + (pivot - obj.simplexX(:,2:end));
            case 'expand'
               newVal         = pivot + obj.expandCoef * (obj.reflectedX - pivot);
            case 'contract'
               newVal         = pivot + obj.contractCoef * (obj.simplexX(:,2:end) - pivot);
         end
         group.moveTo(newVal);
      end
      %%
      function postEval(obj, group)
         if obj.nGen > 0
            switch obj.phase
               case 'reflect'
                  obj.reflectedX = group.getValue();
                  obj.reflectedY = group.getObjective();
                  fx1            = obj.simplexY(1);
                  if min(obj.reflectedY) < fx1
                     % The reflection is successful, try further in that
                     % direction with an expansion step
                     obj.phase = 'expand';
                  else
                     % the reflection has failed, try a contraction step
                     % instead
                     obj.phase = 'contract';
                  end
               case 'expand'
                  fexpanded = group.getObjective();
                  if min(fexpanded) < min(obj.reflectedY)
                     % The expansion step is successful
                     obj.simplexX(:,2:end)   = group.getValue();
                     obj.simplexY(2:end)     = fexpanded;
                  else
                     % The expansion step has failed, fall back to the
                     % reflected values as new simplex
                     obj.simplexX(:,2:end)   = obj.reflectedX;
                     obj.simplexY(2:end)     = obj.reflectedY;
                  end
                  obj.phase = 'reflect';
               case 'contract'
                  fcontracted = group.getObjective();
                  obj.phase   = 'reflect';
                  % In any case, the new simplex is the contracted one
                  obj.simplexX(:,2:end)   = group.getValue();
                  obj.simplexY(2:end)     = fcontracted;
            end
         else
            obj.simplexX = group.getValue();
            obj.simplexY = group.getObjective();
            % kill one individual
            group.at(group.len).kill();
         end
         % Resort elements of the simplex so that the first is the best
         obj.sortSimplex();
      end      
      %% simplexTooSmall
      function [out, msg] = simplexTooSmall(self, group)
         s     = self.simplexSize;
         out   = s < self.tolSimplexSize;
         msg   = '';
         if out 
            msg = sprintf('Size of the simplex below tolerance: %1.2e (tol: %1.2e)', s, self.tolSimplexSize);
         end
      end
      %%
      function out = printSimplexSize(self, group)
         out = sprintf('%1.5e',self.simplexSize);
      end
      %%
      function group = makeGroup(self)
         group = genetic.population.group(self.xDim + 1);
      end
      %% initPopulation
      function x = initPopulation(self, x0)
         %
         if isempty(x0)
            x0 = genetic.population.group.initValue(self.initMethod, 1, [], self.xMin, self.xMax, self.regulariseInit);
         end
         %
         if isa(self.initialSimplex,'double')
            x = self.initialSimplex;
            return
         end
         %
         scale = [];
         if ~isempty(self.initialSimplexSize)
            % If the initial size is provided
            scale = self.initilaSimplexSize;
         else
            % Otherwise, try to determine some size according to the
            % bounding box (if any)
            if self.isBoxBounded
               scale = min(norm(self.xMax - x0,inf),norm(self.xMin - x0,inf));
            end
            
         end
         %
         x = genetic.optimizer.mo.simplex.createSimplex(self.initialSimplex, x0, scale);
      end
   end
end